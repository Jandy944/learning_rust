* 强制解引用，或称为自动解引用

对一个变量做解引用操作`.deref()`会得到一个另一个类型的一个变量的引用，也就是说会自动转化成另一个其他类型引用。而且转换所得来的变量的所有权往往是由做解引用的变量所拥有的，这也是解引用返回的是一个引用而不是一个新的变量实例的一个验证。

以下是解引用的可变性转换规则表

| transform            | when                    |
| -------------------- | ----------------------- |
| `&T` to `&U`         | `T: Deref<Target=U>`    |
| `&T` to `&mut U`     | not possible            |
| `&mut T` to `&U`     | `T: Deref<Target=U>`    |
| `&mut T` to `&mut U` | `T: DerefMut<Target=U>` |
也就是说，`Deref<>`是说明解引用得到一个不可变引用，这对于本身做解引用的变量来说，都是安全的，不会改变状态，因此`&T`和`&mut T`都可以做解引用得到`&U`。如果要解引用得到一个可变引用，只有`&mut T`到`&mut U`。因为解引用所得到的对象也是被做解引用的变量所拥有的，因此二者应该有一致的可变性：`&T`时得不到`&mut U`，因为`U`改变就意味着`T`改变；`&mut T`得到`&mut U`，没问题；
这也可以通过借用的检查规则来说明：同一时间至多只能有一个可变借用，当可变借用存在时，不能有其他任何类型的借用，包括不可变借用（只读）。（这个规则其实也就是说对象的所有权在一个时间点，有且只有一个，而且在可写状态下加了不可读的限制）。